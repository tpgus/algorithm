/*
왕실 정원은 체스판과 같은 8 * 8 좌표 평면이다.
이 정원에 기사가 서있다. 기사는 매우 충성스러운 신하로서 매일 무술을 연마한다.
기사는 말을 타고 있기 대문에 이동할 때에는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다.
기사는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.

1.수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
2.수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기

8 * 8 좌표 평면상에서 기사의 위치가 입력으로 주어질 때 기사가 이동할 수 있는 경우의 수를 출력하시오.
이때 왕실의 정원에서 행 위치를 표현할 때는 1부터 8로 표현하며, 열 위치를 표현할 때는 a부터 h로 표현한다.

예를 들어 기사가 a1에 있을 때 이동할 수 있는 경우의 수는 2가지 이다.
1. 오른쪽으로 두 칸 이동 후 아래로 한 칸 이동 (c2)
2. 아래로 두 칸 이동 후 오른쪽으로 한 칸 이동 (b3)
a1의 위치는 좌표 평면의 왼쪽 상단 구석에 해당하며 기사는 정원 밖으로 나갈 수 없기 때문이다.

[접근 방법]
처음에는 방향 U, D, R, L에 따라 2칸을 이동하고, 움직인 방향과 수직 방향으로 한 칸 이동하는 경우로 생각했었다.
그리고 한 칸씩 이동할 때마다 매번 유효성을 검사하며 진행하려고 했다.
다만, 이럴 경우 로직이 복잡해지고 코드가 길어졌다.

애초에 한 좌표당 최대 8가지 경우의 수가 존재 한다.
따라서 8가지 경우의 수에 따라 변화되는 좌표 값을 구해놓고
반복문을 돌며 현재 좌표에 더했을 때, 이 좌표가 좌표 평면 안에 있는지 검사하면 된다.
*/

function foo(current) {

    let nowX = current[0].charCodeAt() - 97; //좌표가 'a1'처럼 주어진다. 첫 번째 문자를 숫자형으로 바꾸기 위해 아스키코드를 이용했다. (a:97 ~ h:104)
    let nowY = Number(current[1]) - 1;       //나중에 배열의 인덱스로 사용하기 위해 -1을 해주었다.

    const allXY = [[2,-1],[2,1],[-2,1],[-2,-1],[1,2],[-1,2],[1,-2],[-1,-2]]; //8가지 움직임에 대해 좌표가 변화되는 양?수치?값?

    let count = 0;
    for(let i of allXY){ //8번을 반복
        let y = nowY;    //현재 좌표를 반복문 마다 다시 사용해야 하므로, 아예 새로운 변수에 현재 좌표를 할당해놓고 쓴다.
        let x = nowX;

        y += i[0];      //현재 좌표에 더한다.
        x += i[1];

        if(isNotValid(y, x)){ //유효성 검사
            continue;
        }

        count++;
    }
    return count;
}

function isNotValid(nowY, nowX){
    return nowY < 0 || nowY  > 7 || nowX < 0 || nowX > 7; // ||는 앞이 참이면 뒤를 검사하지 않고 참이므로, nowY >= 0 || nowY < 8 이런식으로 검사하면 안 된다.
}

const result = foo('a1');
console.log(result);