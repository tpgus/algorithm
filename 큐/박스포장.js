/*마트에서 장을 보고 박스를 포장하려고 합니다.
박스를 포장하는 데는 폭이 너무 좁습니다. 그렇기에 한 줄로 서 있어야 하고, 들어온 순서대로 한 명씩 나가야 합니다.
불행 중 다행은, 인원에 맞게 포장할 수 있는 기구들이 놓여 있어, 모두가 포장을 할 수 있다는 것입니다.
짐이 많은 사람은 짐이 적은 사람보다 포장하는 시간이 길 수밖에 없습니다.
뒷사람이 포장을 전부 끝냈어도 앞사람이 끝내지 못하면 기다려야 합니다.
앞사람이 포장을 끝내면, 포장을 마친 뒷사람들과 함께 한 번에 나가게 됩니다.
만약, 앞사람의 박스는 5 개고, 뒷사람 1의 박스는 4 개, 뒷사람 2의 박스는 8 개라고 가정했을 때,
뒷사람 1이 제일 먼저 박스 포장을 끝내게 되어도 앞사람 1의 포장이 마칠 때까지 기다렸다가 같이 나가게 됩니다.
이때, 통틀어 최대 몇 명이 한꺼번에 나가는지 알 수 있도록 함수를 구현해 주세요.
(먼저 포장을 전부 끝낸 사람이 있더라도, 앞사람이 포장을 끝내지 않았다면 나갈 수 없습니다.)

-입력 :
Number 타입을 요소로 갖는, 포장해야 하는 박스가 담긴 배열
1 ≤ 사람 수 ≤ 10,000
1 ≤ 박스 ≤ 10,000

-출력 :
Number 타입을 리턴해야 합니다.

--------------------------------
예를 들면, [4,3,2,7]에서 처음 기준이 4가 되고 배열에서 4보다 큰 값인 7의 인덱스 3이 구해진다.
(여기서 구해진 인덱스는 한 번에 나갈 수 있는 인원을 의미한다.)
max의 값은 1이고, 1과 3을 비교해서 3이 더 크니까 현재 한 번에 나갈 수 있는 인원의 최대는 3이다.
그리고 splice를 이용해 나머지 [4,3,2]를 뺀 나머지 배열 [7]을 구한다.
아직 배열의 길이는 1이므로 while 반복문에 진입하게 된다.
그런데 첫 번째 요소인 7을 기준으로 7보다 큰 요소는 없으니 idx는 -1이 된다.
idx가 -1일 때, 나갈 수 있는 인원을 어떻게 표현할 것인가?에 대해 생각해보면 현재 배열의 길이가 되는 것이다.
예를 들어 [4]인 경우와, [8,6,5,3]인 경우 모두, 첫 번째 요소를 기준으로 큰 값이 없으니 idx는 항상 -1을 가리킨다.
이때, 한 번에 나갈 수 있는 인원은 배열의 길이가 된다.
다시 문제로 돌아와 현재 배열은 [7]이므로 idx는 -1이되고, 현재 나갈 수 있는 최대 인원은
배열의 길이인 1이 된다. 그런데 max값은 3이기 때문에 max는 3으로 유지된다.
그리고 현재 배열에서 splice(0,idx=1)를 해주면 [7]에서 []이 되어
반복문을 탈출하게 된다.

위의 로직을 나타낸 것이 아래 코드이다.
*/

function paveBox(boxes) {
    //입력이 최소 1 이상이니까 처음부터 최대값은 1로 설정
    let maxCount = 1;
  
    while (boxes.length > 0) { 
      let pivot = boxes[0];                             //기준을 배열의 첫 번째 요소로 잡아두고
      let idx = boxes.findIndex(item => item > pivot);  //기준보다 큰 값의 인덱스를 찾는다.
  
      if(idx === -1){       //만약 [5, 4, 3] 또는 [5]의 경우처럼 첫 번째 요소보다 큰 값이 없다면, idx를 배열의 길이로 둔다.
        idx = boxes.length;
      }
      if(maxCount < idx){   //그리고 기존의 max값과 비교해서 크다면 max값 변경
        maxCount = idx;
      }
  
      boxes.splice(0,idx);  //while문의 조건에 따라 boxes의 길이는 계속 변화해야 한다.
                            //즉 큐에서 값들을 dequeue해 나가면서, 배열을 나머지 값들로만 이루어지게 한다.
    }
    return maxCount;
  }

